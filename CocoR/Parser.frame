/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University
with changes by Andreas Beham, University of Applied Science Upper Austria

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
----------------------------------------------------------------------*/
-->begin
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

-->namespace
  public class Generator {
-->constants
    private const bool _T = true;
    private const bool _x = false;
    private const int minErrDist = 2;
  
    private Scanner scanner;
    private Errors  errors;
    public Errors Errors { get { return errors; } }

    private Token t;    // last recognized token
    private Token la;   // lookahead token
    private int errDist = minErrDist;

-->declarations

    private void Initialize(string str) {
      this.scanner = new Scanner(new MemoryStream(Encoding.UTF8.GetBytes(str)));
      this.errors = new Errors();
      this.Sentences = new List<List<string>>() { new List<string>() };
      this.Stack = new Stack<List<List<string>>>();
      this.Base = new List<List<string>>();
      this.BaseStack = new Stack<List<List<string>>>();
    }

    private List<List<string>> Sentences { get; set; }
    private Stack<List<List<string>>> Stack { get; set; }
    private List<List<string>> Base { get; set; }
    private Stack<List<List<string>>> BaseStack { get; set; }

    public IEnumerable<string> GetSentences(string separator) {
      return Sentences != null ? Sentences.Select(x => string.Join(separator, x)) : Enumerable.Empty<string>();
    }

    private void RecurseDown() {
      Stack.Push(Sentences);
      Sentences = new List<List<string>>() { new List<string>() };
      BaseStack.Push(Base);
      Base = new List<List<string>>();
    }

    private void RecurseUp(bool option) {
      var sentences = Stack.Pop();
      Sentences = (from mine in sentences
                  from theirs in Sentences
                  select mine.Concat(theirs).ToList()).ToList();
      if (option) Sentences.InsertRange(0, sentences);
      Base = BaseStack.Pop();
    }

    private void SynErr (int n) {
      if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
      errDist = 0;
    }

    private void SemErr (string msg) {
      if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
      errDist = 0;
    }
  
    private void Get () {
      for (;;) {
        t = la;
        la = scanner.Scan();
        if (la.kind <= maxT) { ++errDist; break; }
-->pragmas
        la = t;
      }
    }
  
    private void Expect (int n) {
      if (la.kind==n) Get(); else { SynErr(n); }
    }
  
    private bool StartOf (int s) {
      return set[s, la.kind];
    }
  
    private void ExpectWeak (int n, int follow) {
      if (la.kind == n) Get();
      else {
        SynErr(n);
        while (!StartOf(follow)) Get();
      }
    }

    private bool WeakSeparator(int n, int syFol, int repFol) {
      int kind = la.kind;
      if (kind == n) {
        Get();
        return true;
      } else if (StartOf(repFol)) {
        return false;
      }  else {
        SynErr(n);
        while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind])) {
          Get();
          kind = la.kind;
        }
        return StartOf(syFol);
      }
    }
      
-->productions

    public bool TryParse(string str) {
      Parse(str);
      return Errors.Count == 0;
    }

    public void Parse(string str) {
      Initialize(str);
      la = new Token();
      la.val = "";    
      Get();
-->parseRoot
    }
  
    private static readonly bool[,] set = {
-->initialization
    };
  } // end Parser


  public class Errors {
    private int count = 0;                                    // number of errors detected
    public int Count { get { return count; } }
    private TextWriter errorStream = new StringWriter();   // error messages go to this stream
    public string ErrorMessage {
      get { return errorStream.ToString(); }
    }
    private string errMsgFormat = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text

    internal virtual void SynErr (int line, int col, int n) {
      string s;
      switch (n) {
-->errors
        default: s = "error " + n; break;
      }
      errorStream.WriteLine(errMsgFormat, line, col, s);
      count++;
    }

    internal virtual void SemErr (int line, int col, string s) {
      errorStream.WriteLine(errMsgFormat, line, col, s);
      count++;
    }
  
    internal virtual void SemErr (string s) {
      errorStream.WriteLine(s);
      count++;
    }
  
    internal virtual void Warning (int line, int col, string s) {
      errorStream.WriteLine(errMsgFormat, line, col, s);
    }
  
    internal virtual void Warning(string s) {
      errorStream.WriteLine(s);
    }
  } // Errors


  [Serializable]
  public class FatalError : Exception {
    public FatalError() { }
    public FatalError(string message) : base(message) { }
    public FatalError(string message, Exception inner) : base(message, inner) { }

    protected FatalError(
      System.Runtime.Serialization.SerializationInfo info,
      System.Runtime.Serialization.StreamingContext context) : base(info, context) { }
  }